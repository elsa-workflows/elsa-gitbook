# Tokenized Bookmark Resume Endpoint - Security Best Practices

This document provides detailed security guidance for protecting tokenized bookmark resume URLs in production environments.

---

## Overview

Bookmark resume tokens are generated by `GenerateBookmarkTriggerUrl()` (in `src/modules/Elsa.Http/Extensions/BookmarkExecutionContextExtensions.cs`) and allow external systems or users to resume suspended workflows via HTTP.

**Common Use Cases:**
- Email-based approval workflows
- Webhook callbacks from third-party services
- Multi-step form submissions
- External event notifications

**Security Risk:** Leaked tokens can allow unauthorized workflow resumption, potentially exposing sensitive data or triggering unintended actions.

---

## Critical Security Controls

### 1. Time-to-Live (TTL)

**Recommendation:** Set token TTL based on business requirements, not technical convenience.

**Configuration:**

```csharp
// In Program.cs
builder.Services.AddElsa(elsa =>
{
    elsa.UseIdentity(identity =>
    {
        identity.ConfigureTokenOptions(options =>
        {
            // Short TTL for webhooks (5-15 minutes)
            options.BookmarkResumeTokenLifetime = TimeSpan.FromMinutes(15);
            
            // Longer TTL for email approvals (24-72 hours)
            // options.BookmarkResumeTokenLifetime = TimeSpan.FromHours(24);
        });
    });
});
```

**TTL Guidelines by Use Case:**

| Use Case | Recommended TTL | Rationale |
|----------|-----------------|-----------|
| Webhook callbacks | 5-15 minutes | Short-lived, immediate processing expected |
| Email approvals | 24-72 hours | Users may not check email immediately |
| SMS/Push notifications | 1-4 hours | Mobile users respond quickly |
| Document signing | 7-30 days | Legal review takes time |

**Implementation Notes:**
- Tokens expire automatically; no manual cleanup required
- Expired tokens return `401 Unauthorized`
- Consider business hours when setting TTL (e.g., 48h TTL for weekend approvals)

---

### 2. Single-Use Semantics

**Recommendation:** Ensure tokens are consumed only once to prevent replay attacks.

**Bookmark Creation with AutoBurn:**

```csharp
// In custom activity
var bookmark = context.CreateBookmark(new CreateBookmarkArgs
{
    Name = "ApprovalBookmark",
    Payload = new { ApprovalId = approvalId },
    AutoBurn = true,  // Delete bookmark after first successful resume
    Callback = OnResumeAsync
});
```

**What Happens:**
1. First resume attempt: Bookmark found → Workflow resumes → Bookmark deleted
2. Second resume attempt: Bookmark not found → Returns `404 Not Found`

**Edge Case Handling:**
- If workflow faults during resume, bookmark may not burn (check incident logs)
- Use distributed locking to prevent concurrent resume attempts
- Consider implementing application-level replay protection for critical operations

---

### 3. Revocation Strategy

**Manual Revocation:**

```bash
# Option 1: Cancel the workflow (revokes all bookmarks)
curl -X POST "https://your-elsa-server.com/elsa/api/workflow-instances/{instanceId}/cancel" \
  -H "Authorization: Bearer {your-token}"

# Option 2: Delete specific bookmark (requires direct database access)
DELETE FROM elsa.bookmarks WHERE id = '{bookmarkId}';
```

**Automated Revocation:**
- Implement token revocation list (in-memory cache or Redis)
- Add middleware to check revocation list before processing resume
- Revoke tokens when:
  - User cancels workflow manually
  - Security incident detected (leaked token)
  - Workflow fails irrecoverably

**Example Revocation Middleware:**

```csharp
public class TokenRevocationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IDistributedCache _cache;

    public async Task InvokeAsync(HttpContext context)
    {
        if (context.Request.Path.StartsWithSegments("/elsa/api/bookmarks/resume"))
        {
            var token = context.Request.Query["t"];
            var isRevoked = await _cache.GetStringAsync($"revoked:{token}");
            
            if (isRevoked != null)
            {
                context.Response.StatusCode = 401;
                await context.Response.WriteAsync("Token has been revoked");
                return;
            }
        }
        
        await _next(context);
    }
}
```

---

### 4. Audit Logging

**Recommendation:** Log all resume attempts (success, failure, and anomalies) for security monitoring and forensics.

**Required Log Fields:**

```csharp
_logger.LogInformation(
    "Bookmark resume attempted. " +
    "BookmarkId={BookmarkId}, " +
    "WorkflowInstanceId={WorkflowInstanceId}, " +
    "SourceIp={SourceIp}, " +
    "UserAgent={UserAgent}, " +
    "Success={Success}, " +
    "ErrorCode={ErrorCode}",
    bookmarkId,
    workflowInstanceId,
    context.Connection.RemoteIpAddress,
    context.Request.Headers["User-Agent"],
    success,
    errorCode
);
```

**Security Events to Monitor:**
- **High failure rate:** Possible token enumeration attack
- **Resume after expiration:** User may need TTL extended
- **Multiple resumes on single-use token:** Replay attack or user confusion
- **Resume from unexpected IP/region:** Potential token leak

**Integration with SIEM:**
- Export logs to Splunk, ELK, or Azure Monitor
- Set up alerts for:
  - >10 failed resume attempts per minute (per IP)
  - Resume from blacklisted IP ranges
  - Token reuse on AutoBurn bookmarks

---

### 5. Rate Limiting

**Recommendation:** Implement rate limits at ingress and application layers to prevent abuse.

**Application-Level (ASP.NET Core):**

```csharp
using AspNetCoreRateLimit;

builder.Services.Configure<IpRateLimitOptions>(options =>
{
    options.GeneralRules = new List<RateLimitRule>
    {
        new RateLimitRule
        {
            Endpoint = "POST:/elsa/api/bookmarks/resume",
            Period = "1m",
            Limit = 100  // 100 requests per minute per IP
        }
    };
    options.RealIpHeader = "X-Forwarded-For";
    options.HttpStatusCode = 429;
});
```

**Ingress-Level (Nginx):**

See [ingress-cors-snippet.md](ingress-cors-snippet.md) for full configuration.

```nginx
location /elsa/api/bookmarks/resume {
    limit_req zone=resume_limit burst=5 nodelay;
    limit_req_status 429;
}
```

**Rate Limit Guidelines:**

| Scenario | Limit | Burst |
|----------|-------|-------|
| Public webhooks | 100/min per IP | 5 |
| Internal callbacks | 1000/min per service | 20 |
| Email-triggered approvals | 10/min per token | 3 |

**Handling 429 Responses:**
- Return `Retry-After` header
- Implement exponential backoff in client
- Whitelist trusted IPs if necessary

---

## Example: Secure Resume Request

### Successful Resume

**Request:**
```bash
curl -X POST "https://your-elsa-server.com/elsa/api/bookmarks/resume?t=eyJhbGc..." \
  -H "Content-Type: application/json" \
  -H "User-Agent: ExternalSystem/1.0" \
  -d '{
    "approvalStatus": "approved",
    "comments": "Looks good to me",
    "approver": "john.doe@example.com"
  }'
```

**Response (200 OK):**
```json
{
  "success": true,
  "workflowInstanceId": "abc123",
  "message": "Workflow resumed successfully"
}
```

### Failed Resume (Expired Token)

**Response (401 Unauthorized):**
```json
{
  "success": false,
  "error": "TokenExpired",
  "message": "The resume token has expired. Please request a new approval link."
}
```

### Failed Resume (Already Consumed)

**Response (404 Not Found):**
```json
{
  "success": false,
  "error": "BookmarkNotFound",
  "message": "The bookmark has already been consumed or the workflow has been cancelled."
}
```

### Failed Resume (Rate Limited)

**Response (429 Too Many Requests):**
```http
HTTP/1.1 429 Too Many Requests
Retry-After: 60
Content-Type: application/json

{
  "success": false,
  "error": "RateLimitExceeded",
  "message": "Too many resume attempts. Please try again in 60 seconds."
}
```

---

## Ingress Configuration Hints

### IP Allowlisting (Internal Webhooks)

For webhooks from trusted internal services:

```nginx
# Nginx
location /elsa/api/bookmarks/resume {
    allow 10.0.0.0/8;      # Internal network
    allow 192.168.1.100;   # Specific trusted service
    deny all;
    
    proxy_pass http://elsa-backend;
}
```

```yaml
# Traefik (via middleware)
http:
  middlewares:
    resume-ipwhitelist:
      ipWhiteList:
        sourceRange:
          - "10.0.0.0/8"
          - "192.168.1.100/32"
```

### HTTPS Enforcement

**Always use HTTPS for resume URLs.** Never send tokens over unencrypted connections.

```nginx
# Nginx: Redirect HTTP to HTTPS
server {
    listen 80;
    server_name your-elsa-server.com;
    return 301 https://$server_name$request_uri;
}
```

---

## Least Privilege Principle

**Recommendation:** Resume tokens should grant minimal permissions.

**Token Payload Should Not Include:**
- User credentials
- Full workflow instance state
- Sensitive business data (unless encrypted)

**Token Payload Should Include:**
- Bookmark ID (opaque identifier)
- Workflow instance ID (for routing only)
- Expiration timestamp
- Signature/HMAC for integrity

**Example: Validating Token Integrity**

```csharp
public bool ValidateToken(string token, string signingKey)
{
    var parts = token.Split('.');
    if (parts.Length != 2) return false;
    
    var payload = parts[0];
    var signature = parts[1];
    
    var expectedSignature = ComputeHmac(payload, signingKey);
    return signature == expectedSignature;
}
```

---

## Testing Resume Endpoints

### Unit Test Example

```csharp
[Fact]
public async Task ResumeBookmark_WithValidToken_ShouldSucceed()
{
    // Arrange
    var token = GenerateValidToken(bookmarkId, workflowInstanceId);
    
    // Act
    var response = await _client.PostAsync(
        $"/elsa/api/bookmarks/resume?t={token}",
        JsonContent.Create(new { status = "approved" })
    );
    
    // Assert
    Assert.Equal(HttpStatusCode.OK, response.StatusCode);
}

[Fact]
public async Task ResumeBookmark_WithExpiredToken_ShouldReturn401()
{
    // Arrange
    var token = GenerateExpiredToken(bookmarkId, workflowInstanceId);
    
    // Act
    var response = await _client.PostAsync(
        $"/elsa/api/bookmarks/resume?t={token}",
        JsonContent.Create(new { status = "approved" })
    );
    
    // Assert
    Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
}
```

---

## Related Documentation

- [Security & Authentication Guide](../README.md) - Full security reference
- [CORS and Ingress Configuration](ingress-cors-snippet.md) - Network security
- [Troubleshooting Guide](../../troubleshooting/README.md) (DOC-017) - Diagnosing token issues
- [Clustering Guide](../../clustering/README.md) (DOC-015) - Distributed locking for resume

---

**Last Updated:** 2025-11-25
